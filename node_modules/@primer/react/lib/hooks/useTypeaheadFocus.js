"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useTypeaheadFocus = exports.TYPEAHEAD_TIMEOUT = void 0;

var _react = _interopRequireDefault(require("react"));

var _utils = require("@primer/behaviors/utils");

var _useProvidedRefOrCreate = require("./useProvidedRefOrCreate");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const TYPEAHEAD_TIMEOUT = 1000;
exports.TYPEAHEAD_TIMEOUT = TYPEAHEAD_TIMEOUT;

const useTypeaheadFocus = (open, providedRef) => {
  const containerRef = (0, _useProvidedRefOrCreate.useProvidedRefOrCreate)(providedRef);

  _react.default.useEffect(() => {
    if (!open || !containerRef.current) return;
    const container = containerRef.current;
    let query = '';
    let timeout;

    const handler = event => {
      var _activeElement$textCo;

      // skip if a TextInput has focus
      const activeElement = document.activeElement;
      if (activeElement.tagName === 'INPUT') return; // skip if used with modifier to preserve shortcuts like âŒ˜ + F

      const hasModifier = event.ctrlKey || event.altKey || event.metaKey;
      if (hasModifier) return;

      if (query.length && event.code === 'Space') {
        // prevent the menu from selecting an option
        event.preventDefault();
      } // skip if it's not a alphabet key
      else if (!isAlphabetKey(event)) {
        query = ''; // reset the typeahead query

        return;
      }

      query += event.key.toLowerCase(); // if this is a typeahead event, don't propagate outside of menu

      event.stopPropagation(); // reset the query after timeout

      window.clearTimeout(timeout);
      timeout = window.setTimeout(() => query = '', TYPEAHEAD_TIMEOUT);
      let elementToFocus;
      const focusableItems = [...(0, _utils.iterateFocusableElements)(container)];

      const focusNextMatch = () => {
        var _elementToFocus;

        const itemsStartingWithKey = focusableItems.filter(item => {
          var _item$textContent;

          return (_item$textContent = item.textContent) === null || _item$textContent === void 0 ? void 0 : _item$textContent.toLowerCase().trim().startsWith(query);
        });
        const currentActiveIndex = itemsStartingWithKey.indexOf(activeElement); // If the last element is already selected, cycle through the list

        if (currentActiveIndex === itemsStartingWithKey.length - 1) {
          elementToFocus = itemsStartingWithKey[0];
        } else {
          elementToFocus = itemsStartingWithKey.find((item, index) => {
            return index > currentActiveIndex;
          });
        }

        (_elementToFocus = elementToFocus) === null || _elementToFocus === void 0 ? void 0 : _elementToFocus.focus();
      }; // Single character in query: Jump to the next match


      if (query.length === 1) return focusNextMatch(); // 2 characters in query but the user is pressing
      // the same key, jump to the next match

      if (query.length === 2 && query[0] === query[1]) {
        query = query[0]; // remove the second key

        return focusNextMatch();
      } // More > 1 characters in query
      // If active element satisfies the query stay there,


      if ((_activeElement$textCo = activeElement.textContent) !== null && _activeElement$textCo !== void 0 && _activeElement$textCo.toLowerCase().startsWith(query)) return; // otherwise move to the next one that does.

      return focusNextMatch();
    };

    container.addEventListener('keydown', handler);
    return () => container.removeEventListener('keydown', handler);
  }, [open, containerRef]);

  const isAlphabetKey = event => {
    return event.key.length === 1 && /[a-z\d]/i.test(event.key);
  };

  return {
    containerRef
  };
};

exports.useTypeaheadFocus = useTypeaheadFocus;