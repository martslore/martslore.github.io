{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nimport React, { useRef, useState } from 'react';\nimport { omit } from '@styled-system/props';\nimport { FocusKeys } from '@primer/behaviors';\nimport { useCombinedRefs } from './hooks/useCombinedRefs';\nimport { useFocusZone } from './hooks/useFocusZone';\nimport Token from './Token/Token';\nimport { useProvidedRefOrCreate } from './hooks';\nimport UnstyledTextInput from './_UnstyledTextInput';\nimport TextInputWrapper, { textInputHorizPadding } from './_TextInputWrapper';\nimport Box from './Box';\nimport Text from './Text';\nimport { isFocusable } from '@primer/behaviors/utils'; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nconst overflowCountFontSizeMap = {\n  small: 0,\n  medium: 1,\n  large: 1,\n  extralarge: 2\n}; // using forwardRef is important so that other components (ex. Autocomplete) can use the ref\n\nfunction TextInputWithTokensInnerComponent(_ref, externalRef) {\n  let {\n    icon: IconComponent,\n    leadingVisual: LeadingVisual,\n    trailingVisual: TrailingVisual,\n    contrast,\n    className,\n    block,\n    disabled,\n    theme,\n    sx: sxProp,\n    tokens,\n    onTokenRemove,\n    tokenComponent: TokenComponent,\n    preventTokenWrapping,\n    size,\n    hideTokenRemoveButtons,\n    maxHeight,\n    width: widthProp,\n    minWidth: minWidthProp,\n    maxWidth: maxWidthProp,\n    validationStatus,\n    variant: variantProp,\n    // deprecated. use `size` instead\n    visibleTokenCount,\n    ...rest\n  } = _ref;\n  const {\n    onBlur,\n    onFocus,\n    onKeyDown,\n    ...inputPropsRest\n  } = omit(rest);\n  const ref = useProvidedRefOrCreate(externalRef);\n  const localInputRef = useRef(null);\n  const combinedInputRef = useCombinedRefs(localInputRef, ref);\n  const [selectedTokenIndex, setSelectedTokenIndex] = useState();\n  const [tokensAreTruncated, setTokensAreTruncated] = useState(Boolean(visibleTokenCount));\n  const {\n    containerRef\n  } = useFocusZone({\n    focusOutBehavior: 'wrap',\n    bindKeys: FocusKeys.ArrowHorizontal | FocusKeys.HomeAndEnd,\n    focusableElementFilter: element => {\n      return !element.getAttributeNames().includes('aria-hidden');\n    },\n    getNextFocusable: direction => {\n      var _containerRef$current;\n\n      if (!selectedTokenIndex && selectedTokenIndex !== 0) {\n        return undefined;\n      }\n\n      let nextIndex = selectedTokenIndex + 1; // \"+ 1\" accounts for the first element: the text input\n\n      if (direction === 'next') {\n        nextIndex += 1;\n      }\n\n      if (direction === 'previous') {\n        nextIndex -= 1;\n      }\n\n      if (nextIndex > tokens.length || nextIndex < 1) {\n        return combinedInputRef.current || undefined;\n      }\n\n      return (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.children[nextIndex];\n    }\n  }, [selectedTokenIndex]);\n\n  const handleTokenRemove = tokenId => {\n    onTokenRemove(tokenId); // HACK: wait a tick for the token node to be removed from the DOM\n\n    setTimeout(() => {\n      var _containerRef$current2, _containerRef$current3;\n\n      const nextElementToFocus = (_containerRef$current2 = containerRef.current) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.children[selectedTokenIndex || 0]; // when removing the first token by keying \"Backspace\" or \"Delete\",\n      // `nextFocusableElement` is the div that wraps the input\n\n      const firstFocusable = nextElementToFocus && isFocusable(nextElementToFocus) ? nextElementToFocus : Array.from(((_containerRef$current3 = containerRef.current) === null || _containerRef$current3 === void 0 ? void 0 : _containerRef$current3.children) || []).find(el => isFocusable(el));\n\n      if (firstFocusable) {\n        firstFocusable.focus();\n      } else {\n        var _ref$current; // if there are no tokens left, focus the input\n\n\n        (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.focus();\n      }\n    }, 0);\n  };\n\n  const handleTokenFocus = tokenIndex => () => {\n    setSelectedTokenIndex(tokenIndex);\n  };\n\n  const handleTokenBlur = () => {\n    setSelectedTokenIndex(undefined); // HACK: wait a tick and check the focused element before hiding truncated tokens\n    // this prevents the tokens from hiding when the user is moving focus between tokens,\n    // but still hides the tokens when the user blurs the token by tabbing out or clicking somewhere else on the page\n\n    setTimeout(() => {\n      var _containerRef$current4;\n\n      if (!((_containerRef$current4 = containerRef.current) !== null && _containerRef$current4 !== void 0 && _containerRef$current4.contains(document.activeElement)) && visibleTokenCount) {\n        setTokensAreTruncated(true);\n      }\n    }, 0);\n  };\n\n  const handleTokenKeyUp = event => {\n    if (event.key === 'Escape') {\n      var _ref$current2;\n\n      (_ref$current2 = ref.current) === null || _ref$current2 === void 0 ? void 0 : _ref$current2.focus();\n    }\n  };\n\n  const handleInputFocus = event => {\n    onFocus && onFocus(event);\n    setSelectedTokenIndex(undefined);\n    visibleTokenCount && setTokensAreTruncated(false);\n  };\n\n  const handleInputBlur = event => {\n    onBlur && onBlur(event); // HACK: wait a tick and check the focused element before hiding truncated tokens\n    // this prevents the tokens from hiding when the user is moving focus from the input to a token,\n    // but still hides the tokens when the user blurs the input by tabbing out or clicking somewhere else on the page\n\n    setTimeout(() => {\n      var _containerRef$current5;\n\n      if (!((_containerRef$current5 = containerRef.current) !== null && _containerRef$current5 !== void 0 && _containerRef$current5.contains(document.activeElement)) && visibleTokenCount) {\n        setTokensAreTruncated(true);\n      }\n    }, 0);\n  };\n\n  const handleInputKeyDown = e => {\n    var _ref$current3;\n\n    if (onKeyDown) {\n      onKeyDown(e);\n    }\n\n    if ((_ref$current3 = ref.current) !== null && _ref$current3 !== void 0 && _ref$current3.value) {\n      return;\n    }\n\n    const lastToken = tokens[tokens.length - 1];\n\n    if (e.key === 'Backspace' && lastToken) {\n      handleTokenRemove(lastToken.id);\n\n      if (ref.current) {\n        // TODO: eliminate the first hack by making changes to the Autocomplete component\n        //\n        // HACKS:\n        // 1. Directly setting `ref.current.value` instead of updating state because the autocomplete\n        //    highlight behavior doesn't work correctly if we update the value with a setState action in onChange\n        // 2. Adding an extra space so that when I backspace, it doesn't delete the last letter\n        ref.current.value = `${lastToken.text} `;\n      } // HACK: for some reason we need to wait a tick for `.select()` to work\n\n\n      setTimeout(() => {\n        var _ref$current4;\n\n        (_ref$current4 = ref.current) === null || _ref$current4 === void 0 ? void 0 : _ref$current4.select();\n      }, 0);\n    }\n  };\n\n  const focusInput = () => {\n    var _combinedInputRef$cur;\n\n    (_combinedInputRef$cur = combinedInputRef.current) === null || _combinedInputRef$cur === void 0 ? void 0 : _combinedInputRef$cur.focus();\n  };\n\n  const preventTokenClickPropagation = event => {\n    event.stopPropagation();\n  };\n\n  const visibleTokens = tokensAreTruncated ? tokens.slice(0, visibleTokenCount) : tokens;\n  const inputSizeMap = {\n    small: 'small',\n    medium: 'small',\n    large: 'medium',\n    extralarge: 'medium'\n  };\n  return /*#__PURE__*/React.createElement(TextInputWrapper, {\n    block: block,\n    className: className,\n    contrast: contrast,\n    disabled: disabled,\n    hasLeadingVisual: Boolean(LeadingVisual),\n    hasTrailingVisual: Boolean(TrailingVisual),\n    theme: theme,\n    width: widthProp,\n    minWidth: minWidthProp,\n    maxWidth: maxWidthProp,\n    size: size && inputSizeMap[size],\n    validationStatus: validationStatus,\n    variant: variantProp // deprecated. use `size` prop instead\n    ,\n    onClick: focusInput,\n    sx: {\n      paddingLeft: textInputHorizPadding,\n      py: `calc(${textInputHorizPadding} / 2)`,\n      ...(block ? {\n        display: 'flex',\n        width: '100%'\n      } : {}),\n      ...(maxHeight ? {\n        maxHeight,\n        overflow: 'auto'\n      } : {}),\n      ...(preventTokenWrapping ? {\n        overflow: 'auto'\n      } : {}),\n      ...sxProp\n    }\n  }, IconComponent && !LeadingVisual && /*#__PURE__*/React.createElement(IconComponent, {\n    className: \"TextInput-icon\"\n  }), LeadingVisual && !IconComponent && /*#__PURE__*/React.createElement(\"span\", {\n    className: \"TextInput-icon\"\n  }, typeof LeadingVisual === 'function' ? /*#__PURE__*/React.createElement(LeadingVisual, null) : LeadingVisual), /*#__PURE__*/React.createElement(Box, {\n    ref: containerRef,\n    display: \"flex\",\n    sx: {\n      alignItems: 'center',\n      flexWrap: preventTokenWrapping ? 'nowrap' : 'wrap',\n      marginLeft: '-0.25rem',\n      marginBottom: '-0.25rem',\n      flexGrow: 1,\n      '> *': {\n        flexShrink: 0,\n        marginLeft: '0.25rem',\n        marginBottom: '0.25rem'\n      }\n    }\n  }, /*#__PURE__*/React.createElement(Box, {\n    sx: {\n      order: 1,\n      flexGrow: 1\n    }\n  }, /*#__PURE__*/React.createElement(UnstyledTextInput, _extends({\n    ref: combinedInputRef,\n    disabled: disabled,\n    onFocus: handleInputFocus,\n    onBlur: handleInputBlur,\n    onKeyDown: handleInputKeyDown,\n    type: \"text\",\n    sx: {\n      height: '100%'\n    },\n    \"aria-invalid\": validationStatus === 'error' ? 'true' : 'false'\n  }, inputPropsRest))), TokenComponent ? visibleTokens.map((_ref2, i) => {\n    let {\n      id,\n      ...tokenRest\n    } = _ref2;\n    return /*#__PURE__*/React.createElement(TokenComponent, _extends({\n      key: id,\n      onFocus: handleTokenFocus(i),\n      onBlur: handleTokenBlur,\n      onKeyUp: handleTokenKeyUp,\n      onClick: preventTokenClickPropagation,\n      isSelected: selectedTokenIndex === i,\n      onRemove: () => {\n        handleTokenRemove(id);\n      },\n      hideRemoveButton: hideTokenRemoveButtons,\n      size: size,\n      tabIndex: 0\n    }, tokenRest));\n  }) : null, tokensAreTruncated ? /*#__PURE__*/React.createElement(Text, {\n    color: \"fg.muted\",\n    fontSize: size && overflowCountFontSizeMap[size]\n  }, \"+\", tokens.length - visibleTokens.length) : null), TrailingVisual && /*#__PURE__*/React.createElement(\"span\", {\n    className: \"TextInput-icon\"\n  }, typeof TrailingVisual === 'function' ? /*#__PURE__*/React.createElement(TrailingVisual, null) : TrailingVisual));\n}\n\nTextInputWithTokensInnerComponent.displayName = \"TextInputWithTokensInnerComponent\";\nconst TextInputWithTokens = /*#__PURE__*/React.forwardRef(TextInputWithTokensInnerComponent);\nTextInputWithTokens.defaultProps = {\n  tokenComponent: Token,\n  size: 'extralarge',\n  hideTokenRemoveButtons: false,\n  preventTokenWrapping: false\n};\nTextInputWithTokens.displayName = 'TextInputWithTokens';\nexport default TextInputWithTokens;","map":{"version":3,"sources":["/home/lorenzo/Documenti/Portfolio/node_modules/@primer/react/lib-esm/TextInputWithTokens.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","React","useRef","useState","omit","FocusKeys","useCombinedRefs","useFocusZone","Token","useProvidedRefOrCreate","UnstyledTextInput","TextInputWrapper","textInputHorizPadding","Box","Text","isFocusable","overflowCountFontSizeMap","small","medium","large","extralarge","TextInputWithTokensInnerComponent","externalRef","icon","IconComponent","leadingVisual","LeadingVisual","trailingVisual","TrailingVisual","contrast","className","block","disabled","theme","sx","sxProp","tokens","onTokenRemove","tokenComponent","TokenComponent","preventTokenWrapping","size","hideTokenRemoveButtons","maxHeight","width","widthProp","minWidth","minWidthProp","maxWidth","maxWidthProp","validationStatus","variant","variantProp","visibleTokenCount","rest","onBlur","onFocus","onKeyDown","inputPropsRest","ref","localInputRef","combinedInputRef","selectedTokenIndex","setSelectedTokenIndex","tokensAreTruncated","setTokensAreTruncated","Boolean","containerRef","focusOutBehavior","bindKeys","ArrowHorizontal","HomeAndEnd","focusableElementFilter","element","getAttributeNames","includes","getNextFocusable","direction","_containerRef$current","undefined","nextIndex","current","children","handleTokenRemove","tokenId","setTimeout","_containerRef$current2","_containerRef$current3","nextElementToFocus","firstFocusable","Array","from","find","el","focus","_ref$current","handleTokenFocus","tokenIndex","handleTokenBlur","_containerRef$current4","contains","document","activeElement","handleTokenKeyUp","event","_ref$current2","handleInputFocus","handleInputBlur","_containerRef$current5","handleInputKeyDown","e","_ref$current3","value","lastToken","id","text","_ref$current4","select","focusInput","_combinedInputRef$cur","preventTokenClickPropagation","stopPropagation","visibleTokens","slice","inputSizeMap","createElement","hasLeadingVisual","hasTrailingVisual","onClick","paddingLeft","py","display","overflow","alignItems","flexWrap","marginLeft","marginBottom","flexGrow","flexShrink","order","type","height","map","tokenRest","onKeyUp","isSelected","onRemove","hideRemoveButton","tabIndex","color","fontSize","displayName","TextInputWithTokens","forwardRef","defaultProps"],"mappings":"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","sourcesContent":["function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React, { useRef, useState } from 'react';\nimport { omit } from '@styled-system/props';\nimport { FocusKeys } from '@primer/behaviors';\nimport { useCombinedRefs } from './hooks/useCombinedRefs';\nimport { useFocusZone } from './hooks/useFocusZone';\nimport Token from './Token/Token';\nimport { useProvidedRefOrCreate } from './hooks';\nimport UnstyledTextInput from './_UnstyledTextInput';\nimport TextInputWrapper, { textInputHorizPadding } from './_TextInputWrapper';\nimport Box from './Box';\nimport Text from './Text';\nimport { isFocusable } from '@primer/behaviors/utils'; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nconst overflowCountFontSizeMap = {\n  small: 0,\n  medium: 1,\n  large: 1,\n  extralarge: 2\n}; // using forwardRef is important so that other components (ex. Autocomplete) can use the ref\n\nfunction TextInputWithTokensInnerComponent({\n  icon: IconComponent,\n  leadingVisual: LeadingVisual,\n  trailingVisual: TrailingVisual,\n  contrast,\n  className,\n  block,\n  disabled,\n  theme,\n  sx: sxProp,\n  tokens,\n  onTokenRemove,\n  tokenComponent: TokenComponent,\n  preventTokenWrapping,\n  size,\n  hideTokenRemoveButtons,\n  maxHeight,\n  width: widthProp,\n  minWidth: minWidthProp,\n  maxWidth: maxWidthProp,\n  validationStatus,\n  variant: variantProp,\n  // deprecated. use `size` instead\n  visibleTokenCount,\n  ...rest\n}, externalRef) {\n  const {\n    onBlur,\n    onFocus,\n    onKeyDown,\n    ...inputPropsRest\n  } = omit(rest);\n  const ref = useProvidedRefOrCreate(externalRef);\n  const localInputRef = useRef(null);\n  const combinedInputRef = useCombinedRefs(localInputRef, ref);\n  const [selectedTokenIndex, setSelectedTokenIndex] = useState();\n  const [tokensAreTruncated, setTokensAreTruncated] = useState(Boolean(visibleTokenCount));\n  const {\n    containerRef\n  } = useFocusZone({\n    focusOutBehavior: 'wrap',\n    bindKeys: FocusKeys.ArrowHorizontal | FocusKeys.HomeAndEnd,\n    focusableElementFilter: element => {\n      return !element.getAttributeNames().includes('aria-hidden');\n    },\n    getNextFocusable: direction => {\n      var _containerRef$current;\n\n      if (!selectedTokenIndex && selectedTokenIndex !== 0) {\n        return undefined;\n      }\n\n      let nextIndex = selectedTokenIndex + 1; // \"+ 1\" accounts for the first element: the text input\n\n      if (direction === 'next') {\n        nextIndex += 1;\n      }\n\n      if (direction === 'previous') {\n        nextIndex -= 1;\n      }\n\n      if (nextIndex > tokens.length || nextIndex < 1) {\n        return combinedInputRef.current || undefined;\n      }\n\n      return (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.children[nextIndex];\n    }\n  }, [selectedTokenIndex]);\n\n  const handleTokenRemove = tokenId => {\n    onTokenRemove(tokenId); // HACK: wait a tick for the token node to be removed from the DOM\n\n    setTimeout(() => {\n      var _containerRef$current2, _containerRef$current3;\n\n      const nextElementToFocus = (_containerRef$current2 = containerRef.current) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.children[selectedTokenIndex || 0]; // when removing the first token by keying \"Backspace\" or \"Delete\",\n      // `nextFocusableElement` is the div that wraps the input\n\n      const firstFocusable = nextElementToFocus && isFocusable(nextElementToFocus) ? nextElementToFocus : Array.from(((_containerRef$current3 = containerRef.current) === null || _containerRef$current3 === void 0 ? void 0 : _containerRef$current3.children) || []).find(el => isFocusable(el));\n\n      if (firstFocusable) {\n        firstFocusable.focus();\n      } else {\n        var _ref$current;\n\n        // if there are no tokens left, focus the input\n        (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.focus();\n      }\n    }, 0);\n  };\n\n  const handleTokenFocus = tokenIndex => () => {\n    setSelectedTokenIndex(tokenIndex);\n  };\n\n  const handleTokenBlur = () => {\n    setSelectedTokenIndex(undefined); // HACK: wait a tick and check the focused element before hiding truncated tokens\n    // this prevents the tokens from hiding when the user is moving focus between tokens,\n    // but still hides the tokens when the user blurs the token by tabbing out or clicking somewhere else on the page\n\n    setTimeout(() => {\n      var _containerRef$current4;\n\n      if (!((_containerRef$current4 = containerRef.current) !== null && _containerRef$current4 !== void 0 && _containerRef$current4.contains(document.activeElement)) && visibleTokenCount) {\n        setTokensAreTruncated(true);\n      }\n    }, 0);\n  };\n\n  const handleTokenKeyUp = event => {\n    if (event.key === 'Escape') {\n      var _ref$current2;\n\n      (_ref$current2 = ref.current) === null || _ref$current2 === void 0 ? void 0 : _ref$current2.focus();\n    }\n  };\n\n  const handleInputFocus = event => {\n    onFocus && onFocus(event);\n    setSelectedTokenIndex(undefined);\n    visibleTokenCount && setTokensAreTruncated(false);\n  };\n\n  const handleInputBlur = event => {\n    onBlur && onBlur(event); // HACK: wait a tick and check the focused element before hiding truncated tokens\n    // this prevents the tokens from hiding when the user is moving focus from the input to a token,\n    // but still hides the tokens when the user blurs the input by tabbing out or clicking somewhere else on the page\n\n    setTimeout(() => {\n      var _containerRef$current5;\n\n      if (!((_containerRef$current5 = containerRef.current) !== null && _containerRef$current5 !== void 0 && _containerRef$current5.contains(document.activeElement)) && visibleTokenCount) {\n        setTokensAreTruncated(true);\n      }\n    }, 0);\n  };\n\n  const handleInputKeyDown = e => {\n    var _ref$current3;\n\n    if (onKeyDown) {\n      onKeyDown(e);\n    }\n\n    if ((_ref$current3 = ref.current) !== null && _ref$current3 !== void 0 && _ref$current3.value) {\n      return;\n    }\n\n    const lastToken = tokens[tokens.length - 1];\n\n    if (e.key === 'Backspace' && lastToken) {\n      handleTokenRemove(lastToken.id);\n\n      if (ref.current) {\n        // TODO: eliminate the first hack by making changes to the Autocomplete component\n        //\n        // HACKS:\n        // 1. Directly setting `ref.current.value` instead of updating state because the autocomplete\n        //    highlight behavior doesn't work correctly if we update the value with a setState action in onChange\n        // 2. Adding an extra space so that when I backspace, it doesn't delete the last letter\n        ref.current.value = `${lastToken.text} `;\n      } // HACK: for some reason we need to wait a tick for `.select()` to work\n\n\n      setTimeout(() => {\n        var _ref$current4;\n\n        (_ref$current4 = ref.current) === null || _ref$current4 === void 0 ? void 0 : _ref$current4.select();\n      }, 0);\n    }\n  };\n\n  const focusInput = () => {\n    var _combinedInputRef$cur;\n\n    (_combinedInputRef$cur = combinedInputRef.current) === null || _combinedInputRef$cur === void 0 ? void 0 : _combinedInputRef$cur.focus();\n  };\n\n  const preventTokenClickPropagation = event => {\n    event.stopPropagation();\n  };\n\n  const visibleTokens = tokensAreTruncated ? tokens.slice(0, visibleTokenCount) : tokens;\n  const inputSizeMap = {\n    small: 'small',\n    medium: 'small',\n    large: 'medium',\n    extralarge: 'medium'\n  };\n  return /*#__PURE__*/React.createElement(TextInputWrapper, {\n    block: block,\n    className: className,\n    contrast: contrast,\n    disabled: disabled,\n    hasLeadingVisual: Boolean(LeadingVisual),\n    hasTrailingVisual: Boolean(TrailingVisual),\n    theme: theme,\n    width: widthProp,\n    minWidth: minWidthProp,\n    maxWidth: maxWidthProp,\n    size: size && inputSizeMap[size],\n    validationStatus: validationStatus,\n    variant: variantProp // deprecated. use `size` prop instead\n    ,\n    onClick: focusInput,\n    sx: {\n      paddingLeft: textInputHorizPadding,\n      py: `calc(${textInputHorizPadding} / 2)`,\n      ...(block ? {\n        display: 'flex',\n        width: '100%'\n      } : {}),\n      ...(maxHeight ? {\n        maxHeight,\n        overflow: 'auto'\n      } : {}),\n      ...(preventTokenWrapping ? {\n        overflow: 'auto'\n      } : {}),\n      ...sxProp\n    }\n  }, IconComponent && !LeadingVisual && /*#__PURE__*/React.createElement(IconComponent, {\n    className: \"TextInput-icon\"\n  }), LeadingVisual && !IconComponent && /*#__PURE__*/React.createElement(\"span\", {\n    className: \"TextInput-icon\"\n  }, typeof LeadingVisual === 'function' ? /*#__PURE__*/React.createElement(LeadingVisual, null) : LeadingVisual), /*#__PURE__*/React.createElement(Box, {\n    ref: containerRef,\n    display: \"flex\",\n    sx: {\n      alignItems: 'center',\n      flexWrap: preventTokenWrapping ? 'nowrap' : 'wrap',\n      marginLeft: '-0.25rem',\n      marginBottom: '-0.25rem',\n      flexGrow: 1,\n      '> *': {\n        flexShrink: 0,\n        marginLeft: '0.25rem',\n        marginBottom: '0.25rem'\n      }\n    }\n  }, /*#__PURE__*/React.createElement(Box, {\n    sx: {\n      order: 1,\n      flexGrow: 1\n    }\n  }, /*#__PURE__*/React.createElement(UnstyledTextInput, _extends({\n    ref: combinedInputRef,\n    disabled: disabled,\n    onFocus: handleInputFocus,\n    onBlur: handleInputBlur,\n    onKeyDown: handleInputKeyDown,\n    type: \"text\",\n    sx: {\n      height: '100%'\n    },\n    \"aria-invalid\": validationStatus === 'error' ? 'true' : 'false'\n  }, inputPropsRest))), TokenComponent ? visibleTokens.map(({\n    id,\n    ...tokenRest\n  }, i) => /*#__PURE__*/React.createElement(TokenComponent, _extends({\n    key: id,\n    onFocus: handleTokenFocus(i),\n    onBlur: handleTokenBlur,\n    onKeyUp: handleTokenKeyUp,\n    onClick: preventTokenClickPropagation,\n    isSelected: selectedTokenIndex === i,\n    onRemove: () => {\n      handleTokenRemove(id);\n    },\n    hideRemoveButton: hideTokenRemoveButtons,\n    size: size,\n    tabIndex: 0\n  }, tokenRest))) : null, tokensAreTruncated ? /*#__PURE__*/React.createElement(Text, {\n    color: \"fg.muted\",\n    fontSize: size && overflowCountFontSizeMap[size]\n  }, \"+\", tokens.length - visibleTokens.length) : null), TrailingVisual && /*#__PURE__*/React.createElement(\"span\", {\n    className: \"TextInput-icon\"\n  }, typeof TrailingVisual === 'function' ? /*#__PURE__*/React.createElement(TrailingVisual, null) : TrailingVisual));\n}\n\nTextInputWithTokensInnerComponent.displayName = \"TextInputWithTokensInnerComponent\";\nconst TextInputWithTokens = /*#__PURE__*/React.forwardRef(TextInputWithTokensInnerComponent);\nTextInputWithTokens.defaultProps = {\n  tokenComponent: Token,\n  size: 'extralarge',\n  hideTokenRemoveButtons: false,\n  preventTokenWrapping: false\n};\nTextInputWithTokens.displayName = 'TextInputWithTokens';\nexport default TextInputWithTokens;"]},"metadata":{},"sourceType":"module"}